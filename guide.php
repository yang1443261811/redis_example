<?php
/*----------------------------------------------------------------------------------------------------------------------
 | Redis 事务(事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。)
 |----------------------------------------------------------------------------------------------------------------------
 | 简介:Redis中的事务（transaction）是一组命令的集合。事务同命令一样都是Redis的最小执行单位
 | 1.事务中的所有命令都是序列化且都是按顺序执行的。在一个客户端执行Redis事务的过程中，不会接收其他任何客户端对它发出的请求。这保证了这些命令
 | 是作为一个单独的独立操作执行的。
 |
 | 2.Redis 事务不支持回滚。即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。
 | EXEC会命令触发事务中所有命令的执行。
 |
 | 3.事务的三个阶段 1-->开始事务  2-->命令入队  3-->执行事务.
 | 客户端从非事务状态切换到事务状态(当客户端处于非事务状态下时，
 | 所有发送给服务器端的命令都会立即被服务器执行,但是，当客户端进入事务状态之后，服务器在收到来自客户端的命令时， 不会立即执行，
 | 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队)
 | 如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令：
 | 最先入队的命令最先执行， 而最后入队的命令最后执行。
 |
 | 4.redis 事务 switch命令
 | switch命令是一个乐观锁，只能在客户端进入事务状态之前执行。作用是 exec 命令执行之前，监视任何数量个键，并在 exec 命令执行时，
 | 检查被监视的键是否至少有一个已经被修改过。若是则拒绝执行事务，否则执行。
 |
 | 如下列子:msg 的最终值是 test2, 因为 watch 命令监听到了事务执行之前 msg 的值有过更改 从而导致事务里的命令都没有执行
 | $redis->set('msg', 'test');
 | $redis->watch('msg');
 | $redis->set('msg', 'test2');
 | $redis->multi();
 | $redis->set('msg', 'test3');
 | $redis->incr('number');
 | $redis->exec();
 |
 |
 |
 |
 |---------------------------------------------------------------------------------------------------------------------
 | redis 数据持久化
 |----------------------------------------------------------------------------------------------------------------------
 | 持久化的两种方式：
 | 快照（先把数据拷贝出来，做个备份）：Mysql Dump 和 Redis RDB
 | 日志（某时某点的日志记录）：MySQL Binlog和Hbase HLog和Redis AOF
 |
 |
 |
 |
 |
 |----------------------------------------------------------------------------------------------------------------------
 | 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
 |----------------------------------------------------------------------------------------------------------------------
 | 什么是缓存穿透:
 | 一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询
 | 不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。
 |
 | 如何避免缓存穿透:
 | 1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
 | 2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。
 |
 | 什么是缓存雪崩:
 | 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。
 |
 | 如何避免缓存雪崩:
 | 1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
 | 2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
 | 3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
 |
 |
 |
 |
 |----------------------------------------------------------------------------------------------------------------------
 |
 */